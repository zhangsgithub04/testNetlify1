<h1> Version 6 Grammar of a tinny language (expression, term and factor, 
  two different types of statements and complete program rule</h1>
<ol>
  <li> PROGRAM -> begin BODY end; <li>
    <li> BODY -> STATEMENTS </li>
  <li> STATMENTS -> STATEMENT {[STATEMENT]}</li>
  
  <li> STATEMENT-> ASSIGNMENTSTATEMENT | PRINTSTATEMENT</li>
  
  <li> PRINTSTATEMENT> -> print id {[, id ]}; </li>
  <li> ASSIGNMENTSTATEMENT-> id = EXPR ; </li>
  <li>   EXPR -> TERM {(+|-) TERM}  </li> 
  <li>  TERM -> FACTOR {(*|/) FACTOR}  </li>
<li>FACTOR -> '(' EXPR ')' | identifier | literal constant <li>
  
</ol>


    <input type="text" id="statement" value="8 + 9"> </input>
    <button onclick="run()">Parse me</button>

<script>
  
  function addElement(str="Hi greetings!") {
  // create a new div element
  const newDiv = document.createElement("div");

  // and give it some content
  const newContent = document.createTextNode(str);

  // add the text node to the newly created div
  newDiv.appendChild(newContent);

  // add the newly created element and its content into the DOM
  const currentDiv = document.getElementById("div1");
  document.body.insertBefore(newDiv, currentDiv); // if div1 exists, after it. Otherwise ...
}
  

  /* expr
   Parses strings in the language generated by the rule:
   <expr> -> <term> {(+ | -) <term>}
   */

  var lexemes = null;
  var lexeme=null;
  var nextToken=null;
  
  var flag=true;
  
  var length=0;
  var index=0;

  
  const SENTINEL=0;
  const ADD_OP=1;
  const SUB_OP=2;
  const MULT_OP=3;
  const DIV_OP=4;
  const LEFT_PAREN=5;
  const RIGHT_PAREN=6;
  const IDENT=7;
  const INT_LIT=8;
  const EXPONENTIATION=9;
  const ASSIGNMENT=10;
   const SEMICOLON=11; 
   const PRINT=12;
  

  function run()
    {
      
      const statement=document.getElementById("statement").value.trim();
      
      initialize(statement);

      
    }
  
  function initialize(s = '5 - 3')
    {
        nextToken=null;
  
       flag=true;
      
      addElement("<hr> Analyzing "+ statement + "<br>");
       lexemes = s.split(' ');
       addElement(JSON.stringify(lexemes));
      
       length=lexemes.length; 
       index=0;
      
   
      lex();
      
      statement(); //not in

        if (nextToken!=SENTINEL)
  {
    error("More tokens found, but not for a ligitimate statement");
  }
      
      if (flag)
        msg="Success";
      else
        msg="Failed";
      
      addElement(msg);
      
      addElement(flag? "Success!": "Failed sorry!"); 
      
      
    }

  function isakeyword()
    {
      switch (lexeme)
        {
          case "print": nextToken=PRINT;
            break;
        }
    }
  
function whichToken()
  {
    
      switch (lexeme){
        case "+": nextToken=ADD_OP;
                  break;
        case "-": nextToken=ADD_OP;
                  break;
        case "*": nextToken=MULT_OP;
                  break;
        case "/": nextToken=DIV_OP;
                  break;
        case "(": nextToken=LEFT_PAREN;
                  break;
        case ")": nextToken=RIGHT_PAREN;
                  break;
        case "^":   nextToken=EXPONENTIATION;
                  break;
        case "=": nextToken=ASSIGNMENT;
                  break;
        case ';': nextToken=SEMICOLON;
                break;
          
        default: 
            if (!isNaN(lexeme)) 
                nextToken=INT_LIT;
            else 
            {
              nextToken=IDENT; // temporarily ID, to be separated from Literals now.
              isakeyword();
              
            }
    
      }
    
    
  }
  
  function lex() 
  {
   mesg("next lex<br>");
    if (index==length) 
   {
     mesg("No more lexeme, exausted");
     nextToken=SENTINEL;
     
   }
   
    else{
      mesg(index);
    lexeme=lexemes[index++]; //side effect
     whichToken();
   }
  }

  function statement()
    {
      
      addElement("Enter <statement>\n");
      // this assumes the first non-terminal of all the alternate rules are unique! 
      switch (nextToken) // lookahead.
        {
          case IDENT:
            assignmentstatement(); // this functions needs to be fixed later.
            break;
          case PRINT:
            printstatement();
            
        }
      
      addElement("Exit <statement>\n");
    }

    function assignmentstatement()
    {
  addElement("Enter <assignmentstatement>\n");
  
      if (nextToken==IDENT)
      {
        lex();
        if (nextToken==ASSIGNMENT)
        {
          lex();
          expr();
            if (nextToken==SEMICOLON)
            {
              mesg("An assignment Statement has been found so far!");
               lex();
            }
          else 
              error("Expecting  ; operator");
        }
        else
          error("Expecting  = operator");
      }
      else
      {
        error("Expecting an id");
      }
    
      addElement("Exit <assignmentstatement>\n");
    }
  function printstatement()
    {
  addElement("Enter <printstatement>\n");
  
      if (nextToken==PRINT)
      {
        lex();
        if (nextToken==ASSIGNMENT)
        {
          lex();
          expr();
            if (nextToken==SEMICOLON)
            {
              mesg("An assignment Statement has been found so far!");
               lex();
            }
          else 
              error("Expecting  ; operator");
        }
        else
          error("Expecting  = operator");
      }
      else
      {
        error("Expecting an id");
      }
    
      addElement("Exit <assignmentstatement>\n");
    }

  
function expr() { 
  
  addElement("Enter <expr>\n");
  term(); /* Parse the first term */

/* As long as the next token is + or -, get
   the next token and parse the next term */

  while (nextToken == ADD_OP || nextToken == SUB_OP) { 
    
    addElement(nextToken);
    
    lex();
    
    term(); 
  }

  
  addElement("Exit <expr>\n");
  
}  /* End of function expr */

  /* term
   Parses strings in the language generated by the rule:
   <term> -> <factor> {(* | /) <factor>)
   */
function term() { 
  addElement("Enter <term>\n");

  /* Parse the first factor */
  factor();

  /* As long as the next token is * or /, get the
   next token and parse the next factor */
while (nextToken == MULT_OP || nextToken == DIV_OP) { 
      addElement(nextToken);
  lex();
factor(); 
                                                    }
  addElement("Exit <term>\n");
}  /* End of function term */


  /* factor
   Parses strings in the language generated by the rule:
   <factor> -> id | int_constant | ( <expr )
   */
function factor() { 
  addElement("Enter <factor>\n");
                   addElement(lexeme + ": " + nextToken);
/* Determine which RHS */
if (nextToken == IDENT || nextToken == INT_LIT)
{
    addElement(nextToken);
  /* Get the next token */
    lex();
}
  /* If the RHS is ( <expr>), call lex to pass over the
   left parenthesis, call expr, and check for the right
   parenthesis */
else {
if (nextToken == LEFT_PAREN) {
      addElement(nextToken);
lex();
expr();
if (nextToken == RIGHT_PAREN)
{
      addElement(nextToken);
lex();
}
else
        error("Expecting )");
    }  /* End of if (nextToken == ... */
/* It was not an id, an integer literal, or a left
   parenthesis */
else
      error("Expecting (");
  }  /* End of else */
  addElement("Exit <factor>\n");;
}  /* End of function factor */

  function error(e="Something unexpected! An Error!")
  {
      addElement(e); 
      flag=false;

  }

  function  mesg(e="ok")
  {
    addElement(e); 
  }

</script>
